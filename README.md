# Как запускать?
Если находитесь в директории pubsub, то:
```
go build -o pubsub-server.exe ./cmd/server/main.go
./pubsub-server.exe
```
# Конфигурация
Конфигурация возможна как через переменные окружения, так и черезе json. В приложении оставлена конфигурация в файле config.json

# Как работает сервис
Сервис реализован по модели **Publisher-Subscriber** и работает поверх gRPC-стриминга.
- **Subscriber**: клиент открывает поток, указывая `key`. Всё публикации по этому ключу будут приходить сюда клиенту.
- **Publisher**: отправляется сообщение с указанным `key`. Все подписчики, подписанные на этот ключ, получат указанное сообщение(`data`).

# Реализация по пунктам из задания
- **На один subject может подписываться (и отписываться) множество подписчиков** - реализовано.
- **Один медленный подписчик не должен тормозить остальных** - реализовано с помощью буфферезированных каналов на 100 сообщений
- **Нельзя терять порядок порядок сообщений (FIFO очередь)** - реализовано. Написан unit-тест на это поведение. 
- **Метод Close должен учитывать переданный контекст. Если он отменен - выходим сразу, работающие хендлеры оставляем работать** - сообщения оставшиеся доходят. Хэндлеры продолжают работать до того момента, пока сами не завершат свою работу. Всё четко по заданию, хотя ыло бы логично их завершать через какое-то время.
- **Горутины (если они будут) течь не должны** - не текут. 
Что горутины не текут можно проверить, например, через вот такую функцию(сам ей пользовался на всякий случай):
```
func monitorGoroutines() {
	for {
		time.Sleep(5 * time.Second)
		fmt.Printf("Number of goroutines: %d\n", runtime.NumGoroutine())
	}
}
```
